// Class: ReadBDT_VBF0LowVPtHighMJJ
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT_VBF0LowVPtHighMJJ
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.10/09       [395785]
Creator        : ajafari
Date           : Fri Nov 30 14:41:22 2018
Host           : Linux cmsbuild49.cern.ch 2.6.32-696.10.2.el6.x86_64 #1 SMP Thu Sep 14 16:35:02 CEST 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /afs/cern.ch/work/a/ajafari/Vjj/CMSSW_9_4_2/src/TopLJets2015/TopAnalysis/macro
Training events: 26262
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "True" [Create PDFs for classifier outputs (signal and background)]
nCuts: "0" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "6.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "4" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 16
mjj                           mjj                           mjj                           mjj                                                             'F'    [1000.02545166,9690.50488281]
dphijj                        dphijj                        dphijj                        dphijj                                                          'F'    [-3.14146089554,3.14152264595]
ystar                         ystar                         ystar                         ystar                                                           'F'    [-3.5614168644,3.07476449013]
dphibjj                       dphibjj                       dphibjj                       dphibjj                                                         'F'    [-3.14157533646,3.14157009125]
balance                       balance                       balance                       balance                                                         'F'    [0.323038250208,587.776916504]
subleadj_gawidth              subleadj_gawidth              subleadj_gawidth              subleadj_gawidth                                                'F'    [0.0101682143286,0.593716979027]
j_c2_00[0]                    j_c2_00_0_                    j_c2_00[0]                    jet_c2_001                                                      'F'    [-1,0.651101589203]
j_c2_00[1]                    j_c2_00_1_                    j_c2_00[1]                    jet_c2_002                                                      'F'    [-1,0.641687572002]
j_qg[0]                       j_qg_0_                       j_qg[0]                       leadjet_qg                                                      'F'    [-1,1]
dphivj0                       dphivj0                       dphivj0                       dphivj0                                                         'F'    [0.00175261497498,3.14147353172]
dphivj2                       dphivj2                       dphivj2                       dphivj2                                                         'F'    [0.00177586078644,9999]
mht                           mht                           mht                           mht                                                             'F'    [4.04388141632,641.40826416]
ht                            ht                            ht                            ht                                                              'F'    [80.6170196533,1739.7734375]
aplanarity                    aplanarity                    aplanarity                    aplanarity                                                      'F'    [4.72400590867e-12,0.100013256073]
sphericity                    sphericity                    sphericity                    sphericity                                                      'F'    [0.00536917801946,0.533853709698]
circularity                   circularity                   circularity                   circularity                                                     'F'    [0.00168784300331,0.897996246815]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDT_VBF0LowVPtHighMJJNode
   
#ifndef BDT_VBF0LowVPtHighMJJNode__def
#define BDT_VBF0LowVPtHighMJJNode__def
   
class BDT_VBF0LowVPtHighMJJNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDT_VBF0LowVPtHighMJJNode ( BDT_VBF0LowVPtHighMJJNode* left,BDT_VBF0LowVPtHighMJJNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT_VBF0LowVPtHighMJJNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT_VBF0LowVPtHighMJJNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT_VBF0LowVPtHighMJJNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT_VBF0LowVPtHighMJJNode*   fLeft;     // pointer to the left daughter node
   BDT_VBF0LowVPtHighMJJNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDT_VBF0LowVPtHighMJJNode::~BDT_VBF0LowVPtHighMJJNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDT_VBF0LowVPtHighMJJNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDT_VBF0LowVPtHighMJJNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT_VBF0LowVPtHighMJJ : public IClassifierReader {

 public:

   // constructor
   ReadBDT_VBF0LowVPtHighMJJ( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT_VBF0LowVPtHighMJJ" ),
        fNvars( 16 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "mjj", "dphijj", "ystar", "dphibjj", "balance", "subleadj_gawidth", "j_c2_00[0]", "j_c2_00[1]", "j_qg[0]", "dphivj0", "dphivj2", "mht", "ht", "aplanarity", "sphericity", "circularity" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;
      fVmin[11] = 0;
      fVmax[11] = 0;
      fVmin[12] = 0;
      fVmax[12] = 0;
      fVmin[13] = 0;
      fVmax[13] = 0;
      fVmin[14] = 0;
      fVmax[14] = 0;
      fVmin[15] = 0;
      fVmax[15] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';
      fType[15] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT_VBF0LowVPtHighMJJ() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[16];
   double fVmax[16];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[16];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT_VBF0LowVPtHighMJJNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT_VBF0LowVPtHighMJJ::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT_VBF0LowVPtHighMJJNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT_VBF0LowVPtHighMJJNode*)current->GetRight();
         else current=(BDT_VBF0LowVPtHighMJJNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT_VBF0LowVPtHighMJJ::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.386906300553049);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.82045, 0, 1, 0.734443,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607284,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.368583,-99) , 
2, -1.16406, 0, 0, 0.558937,-99) , 
NN(
0, 
0, 
-1, 0.268437, 1, -1, 0.348701,-99) , 
4, 41.0009, 1, 0, 0.437265,-99) , 
0, 1734.24, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.313504);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.646323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48591,-99) , 
0, 1231.99, 0, 0, 0.583123,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.247076,-99) , 
2, -1.68129, 0, 0, 0.545473,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.274308,-99) , 
2, 1.39518, 1, 0, 0.507958,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.290345);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.747625, 0, 1, 0.621513,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378088,-99) , 
8, 0.785866, 0, 0, 0.445491,-99) , 
2, 0.861704, 1, 0, 0.57762,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.598947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.395569,-99) , 
10, 3.11391, 0, 0, 0.491944,-99) , 
NN(
0, 
0, 
-1, 272.859, 0, -1, 0.323944,-99) , 
9, 2.83147, 1, 0, 0.42633,-99) , 
5, 0.278427, 1, 0, 0.516156,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.276246);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400514,-99) , 
8, 0.212397, 0, 0, 0.568461,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377891,-99) , 
0, 1720.7, 0, 0, 0.413423,-99) , 
2, 0.792091, 1, 0, 0.519365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296891,-99) , 
2, -1.6621, 0, 0, 0.4976,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.177445);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.726329,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.377234,-99) , 
5, 0.372887, 1, 0, 0.505598,-99) , 
0, 2134.27, 0, 0, 0.524703,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507978,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3927,-99) , 
1, 1.80926, 0, 0, 0.436315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.286609,-99) , 
2, -0.997559, 0, 0, 0.399501,-99) , 
4, 72.1675, 1, 0, 0.48762,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.179241);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535759,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334338,-99) , 
12, 613.408, 1, 0, 0.519518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331451,-99) , 
2, 1.67479, 1, 0, 0.498193,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508907,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398692,-99) , 
15, 0.497396, 0, 0, 0.441663,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.315933,-99) , 
4, 55.3665, 1, 0, 0.386047,-99) , 
2, -0.990503, 0, 0, 0.470935,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.196463);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.621479,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460435,-99) , 
10, 2.99876, 0, 0, 0.511253,-99) , 
NN(
0, 
0, 
-1, 1.80033, 0, -1, 0.411811,-99) , 
1, -2.27904, 1, 0, 0.442395,-99) , 
4, 13.6224, 1, 0, 0.455379,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.157223);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630366,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464783,-99) , 
1, 2.35356, 0, 0, 0.494079,-99) , 
NN(
0, 
0, 
-1, 1548.59, 0, -1, 0.396493,-99) , 
14, 0.0612518, 0, 0, 0.470866,-99) , 
0, 2134.27, 0, 0, 0.485261,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.186479);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 3.10479, 0, 1, 0.584858,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438376,-99) , 
2, -1.23823, 0, 0, 0.556837,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47098,-99) , 
7, 0.538588, 1, 0, 0.543848,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.296554,-99) , 
1, 2.06834, 0, 0, 0.428292,-99) , 
1, -2.24317, 1, 0, 0.471566,-99) , 
15, 0.507506, 0, 0, 0.502518,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.128649);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.622509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495117,-99) , 
2, -0.396363, 0, 0, 0.554194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458416,-99) , 
2, 0.955926, 1, 0, 0.530735,-99) , 
NN(
0, 
0, 
-1, 1.33182, 0, -1, 0.447941,-99) , 
1, -1.24054, 1, 0, 0.484922,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.120273);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635376,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531046,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453121,-99) , 
14, 0.064312, 0, 0, 0.510306,-99) , 
0, 2035.34, 0, 0, 0.521948,-99) , 
NN(
0, 
0, 
-1, -1.98677, 1, -1, 0.41662,-99) , 
12, 512.506, 1, 0, 0.507377,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.108188);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2715.79, 0, 1, 0.529027,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516576,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.373597,-99) , 
15, 0.235332, 1, 0, 0.454757,-99) , 
9, 2.86313, 1, 0, 0.50799,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.385939,-99) , 
6, 0.602087, 1, 0, 0.498231,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.114835);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630375,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518584,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416248,-99) , 
14, 0.0448517, 0, 0, 0.503492,-99) , 
12, 212.688, 1, 0, 0.517388,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379996,-99) , 
12, 515.375, 1, 0, 0.48728,-99) , 
NN(
0, 
0, 
-1, 2.64598, 1, -1, 0.387374,-99) , 
1, 1.80033, 0, 0, 0.456643,-99) , 
1, -1.7392, 1, 0, 0.481542,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.114903);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.624078,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473472,-99) , 
4, 12.0932, 1, 0, 0.48183,-99) , 
NN(
0, 
0, 
-1, 1471.82, 0, -1, 0.423703,-99) , 
6, 0.556013, 1, 0, 0.464728,-99) , 
0, 2727, 0, 0, 0.47013,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.119349);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599656,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478692,-99) , 
10, 2.86892, 0, 0, 0.536949,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461779,-99) , 
15, 0.558002, 0, 0, 0.483133,-99) , 
0, 1426.78, 0, 0, 0.503913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415384,-99) , 
2, 1.57393, 1, 0, 0.494979,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0848249);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.656058,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493313,-99) , 
14, 0.10517, 0, 0, 0.511995,-99) , 
7, 0.39757, 1, 0, 0.521085,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526591,-99) , 
NN(
0, 
0, 
-1, -1.34987, 1, -1, 0.442521,-99) , 
0, 1471.82, 0, 0, 0.466203,-99) , 
6, 0.55602, 1, 0, 0.505357,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.106725);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.632762,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57942,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480286,-99) , 
10, 2.80651, 1, 0, 0.521836,-99) , 
0, 1603.68, 0, 0, 0.548789,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640083,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471727,-99) , 
15, 0.389743, 0, 0, 0.557394,-99) , 
NN(
0, 
0, 
-1, 2.91537, 1, -1, 0.479608,-99) , 
14, 0.0578133, 1, 0, 0.496356,-99) , 
1, -2.28531, 1, 0, 0.512872,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.105331);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.645227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488641,-99) , 
15, 0.263541, 0, 0, 0.593814,-99) , 
NN(
0, 
0, 
-1, 12.7054, 1, 1, 0.525928,-99) , 
5, 0.139575, 1, 0, 0.541132,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586385,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484908,-99) , 
0, 1408.51, 0, 0, 0.512268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414545,-99) , 
12, 478.948, 1, 0, 0.489555,-99) , 
6, 0.55602, 1, 0, 0.526361,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0872886);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492441,-99) , 
2, -0.887819, 0, 0, 0.527287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430414,-99) , 
4, 141.774, 1, 0, 0.521302,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429652,-99) , 
5, 0.422879, 1, 0, 0.514871,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.122069);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 64.8796, 1, 1, 0.618189,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629755,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492971,-99) , 
12, 193.597, 1, 0, 0.508532,-99) , 
2, -0.118662, 0, 0, 0.532359,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438393,-99) , 
13, 0.00133393, 0, 0, 0.50219,-99) , 
NN(
0, 
0, 
-1, 1.02277, 0, -1, 0.409921,-99) , 
4, 29.8638, 0, 0, 0.472184,-99) , 
2, 0.434043, 1, 0, 0.508971,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.109905);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 179.528, 1, 1, 0.547653,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554777,-99) , 
NN(
0, 
0, 
-1, 81.8668, 0, -1, 0.460033,-99) , 
14, 0.0539759, 1, 0, 0.47916,-99) , 
2, 0.306181, 1, 0, 0.518667,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.101811);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617555,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485275,-99) , 
3, 2.87824, 0, 0, 0.513094,-99) , 
0, 1726.97, 0, 0, 0.530672,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485143,-99) , 
3, -2.38485, 1, 0, 0.508995,-99) , 
NN(
0, 
0, 
-1, -0.906336, 1, -1, 0.43246,-99) , 
4, 41.4358, 0, 0, 0.491335,-99) , 
10, 3.10711, 0, 0, 0.509834,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0779819);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.28531, 1, 1, 0.529537,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443303,-99) , 
14, 0.0346954, 0, 0, 0.52332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455925,-99) , 
2, 1.7109, 1, 0, 0.518221,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0793813);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.662667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437131,-99) , 
6, 0.56366, 1, 0, 0.509819,-99) , 
12, 288.584, 1, 0, 0.536816,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561848,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403528,-99) , 
9, 2.91537, 1, 0, 0.485341,-99) , 
15, 0.162255, 1, 0, 0.494655,-99) , 
5, 0.139575, 1, 0, 0.504293,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0973309);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644699,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537323,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444068,-99) , 
4, 42.8745, 0, 0, 0.501709,-99) , 
12, 288.584, 1, 0, 0.526771,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545974,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480351,-99) , 
3, 2.97221, 0, 0, 0.49402,-99) , 
NN(
0, 
0, 
-1, 2.44813, 1, -1, 0.436369,-99) , 
9, 2.20719, 0, 0, 0.480582,-99) , 
5, 0.139575, 1, 0, 0.491113,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.10185);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56044,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489187,-99) , 
6, 0.517473, 0, 0, 0.521459,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436868,-99) , 
1, -1.0837, 1, 0, 0.474436,-99) , 
10, 1.67042, 0, 0, 0.509816,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.383501,-99) , 
15, 0.425679, 1, 0, 0.451126,-99) , 
3, 3.03214, 1, 0, 0.501895,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0718631);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.9294, 0, 1, 0.523966,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503807,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.418398,-99) , 
0, 1637.79, 1, 0, 0.477696,-99) , 
10, 1.67042, 0, 0, 0.512521,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514567,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.379666,-99) , 
6, 0.536394, 1, 0, 0.453575,-99) , 
3, 3.03214, 1, 0, 0.504596,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0495924);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580645,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556882,-99) , 
NN(
0, 
0, 
-1, 609.793, 1, -1, 0.48379,-99) , 
6, 0.365597, 1, 0, 0.488155,-99) , 
0, 2727, 0, 0, 0.491157,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0548473);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568718,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466608,-99) , 
9, 2.21367, 0, 0, 0.500432,-99) , 
0, 2121.79, 0, 0, 0.505653,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440694,-99) , 
12, 613.919, 1, 0, 0.501346,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0549699);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494467,-99) , 
14, 0.112565, 0, 0, 0.50732,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438853,-99) , 
6, 0.601456, 1, 0, 0.501942,-99) , 
NN(
0, 
0, 
-1, 0.233379, 1, -1, 0.455779,-99) , 
0, 1069.83, 0, 0, 0.495052,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.109705);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48123,-99) , 
10, 2.4382, 0, 0, 0.547064,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484023,-99) , 
4, 72.6858, 0, 0, 0.498644,-99) , 
0, 1549.48, 0, 0, 0.512052,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448986,-99) , 
6, 0.500463, 1, 0, 0.523464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.390767,-99) , 
13, 0.00137835, 0, 0, 0.465057,-99) , 
11, 162.686, 1, 0, 0.503327,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0611272);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.597943,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520001,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459795,-99) , 
12, 165.968, 0, 0, 0.515596,-99) , 
0, 2727, 0, 0, 0.51812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448735,-99) , 
4, 142.887, 1, 0, 0.514012,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.080192);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -3.05672, 0, 1, 0.55061,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528011,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480587,-99) , 
11, 107.134, 0, 0, 0.501646,-99) , 
3, -2.95679, 1, 0, 0.510526,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410869,-99) , 
13, 0.00192477, 0, 0, 0.467626,-99) , 
11, 162.686, 1, 0, 0.502588,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0806891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.60332,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520363,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460205,-99) , 
10, 1.38097, 0, 0, 0.509053,-99) , 
0, 2277.16, 0, 0, 0.514394,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537939,-99) , 
NN(
0, 
0, 
-1, 0.101647, 0, -1, 0.452601,-99) , 
6, 0.450235, 1, 0, 0.469831,-99) , 
11, 142.609, 1, 0, 0.501112,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0681597);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484547,-99) , 
2, 0.213328, 1, 0, 0.506926,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455517,-99) , 
2, -1.49308, 0, 0, 0.500309,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441299,-99) , 
13, 0.0231368, 1, 0, 0.49556,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0905929);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603445,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440791,-99) , 
5, 0.34868, 1, 0, 0.503287,-99) , 
2, 0.153406, 1, 0, 0.516103,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575571,-99) , 
NN(
0, 
0, 
-1, 0.634481, 1, -1, 0.469309,-99) , 
12, 193.293, 1, 0, 0.480804,-99) , 
2, -0.157354, 0, 0, 0.499455,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0646093);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.595791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489318,-99) , 
7, 0.40622, 1, 0, 0.4963,-99) , 
3, -2.95735, 1, 0, 0.505609,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517072,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417294,-99) , 
1, 0.334802, 0, 0, 0.462711,-99) , 
3, -3.05515, 0, 0, 0.500618,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0675382);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.619295,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518496,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471446,-99) , 
0, 1069.83, 0, 0, 0.511398,-99) , 
3, -3.00613, 1, 0, 0.516518,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52184,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423821,-99) , 
9, 2.70143, 1, 0, 0.46405,-99) , 
3, -3.05515, 0, 0, 0.510424,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0552457);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556471,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506885,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438706,-99) , 
13, 0.0202383, 1, 0, 0.500521,-99) , 
15, 0.701775, 0, 0, 0.507038,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413991,-99) , 
7, 0.406265, 1, 0, 0.464564,-99) , 
7, 0.445917, 0, 0, 0.500148,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0619493);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547049,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62777,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492167,-99) , 
0, 2015.61, 0, 0, 0.503305,-99) , 
NN(
0, 
0, 
-1, 0.469659, 0, -1, 0.468868,-99) , 
11, 114.553, 1, 0, 0.486475,-99) , 
14, 0.180441, 0, 0, 0.490549,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0892923);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593576,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48387,-99) , 
5, 0.195338, 1, 0, 0.503107,-99) , 
6, 0.584666, 0, 0, 0.513196,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525461,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462491,-99) , 
4, 49.6088, 0, 0, 0.503862,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399309,-99) , 
6, 0.584456, 1, 0, 0.481624,-99) , 
12, 380.646, 1, 0, 0.502756,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0944007);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.606314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491695,-99) , 
12, 289.622, 1, 0, 0.553618,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442094,-99) , 
13, 0.00310882, 1, 0, 0.505722,-99) , 
13, 0.00589514, 0, 0, 0.518885,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546603,-99) , 
NN(
0, 
0, 
-1, 2.83847, 1, -1, 0.463426,-99) , 
8, 0.991387, 0, 0, 0.480794,-99) , 
12, 380.646, 1, 0, 0.506299,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0783793);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588461,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521059,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47441,-99) , 
3, 2.75103, 1, 0, 0.50514,-99) , 
7, 0.486883, 1, 0, 0.512672,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531951,-99) , 
NN(
0, 
0, 
-1, 306.421, 0, -1, 0.4474,-99) , 
0, 1229.99, 1, 0, 0.477442,-99) , 
7, 0.469819, 0, 0, 0.504124,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.055557);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591439,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48254,-99) , 
8, 0.888004, 1, 0, 0.501058,-99) , 
3, -3.00613, 1, 0, 0.505305,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504778,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422021,-99) , 
8, 0.860021, 0, 0, 0.458459,-99) , 
3, -3.05515, 0, 0, 0.499881,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0493878);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577949,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525039,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489037,-99) , 
1, -2.3832, 1, 0, 0.499582,-99) , 
3, -3.00613, 1, 0, 0.50325,-99) , 
NN(
0, 
0, 
-1, 1.45251, 0, -1, 0.460022,-99) , 
3, -3.05515, 0, 0, 0.498251,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0452275);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.589898,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510853,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466342,-99) , 
7, 0.436146, 0, 0, 0.5046,-99) , 
0, 2727, 0, 0, 0.507207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437448,-99) , 
1, -3.0217, 0, 0, 0.503488,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0887655);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 211.283, 1, 1, 0.537984,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502188,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40762,-99) , 
10, 3.07714, 1, 0, 0.454544,-99) , 
7, 0.548752, 1, 0, 0.510785,-99) , 
NN(
NN(
0, 
0, 
-1, 0.316708, 0, 1, 0.510698,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516967,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399807,-99) , 
1, 2.37963, 0, 0, 0.441358,-99) , 
13, 0.00114921, 0, 0, 0.484388,-99) , 
3, 2.17844, 0, 0, 0.496302,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.117237);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631133,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423658,-99) , 
9, 2.61798, 1, 0, 0.518819,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474867,-99) , 
5, 0.198193, 0, 0, 0.514408,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452588,-99) , 
9, 2.94474, 0, 0, 0.463803,-99) , 
8, 0.978729, 0, 0, 0.476978,-99) , 
12, 206.035, 1, 0, 0.483318,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0521154);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.483286, 1, 1, 0.556895,-99) , 
NN(
0, 
0, 
-1, 227.163, 0, -1, 0.49186,-99) , 
12, 207.292, 1, 0, 0.501755,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404621,-99) , 
1, -1.36835, 1, 0, 0.44452,-99) , 
9, 3.0065, 1, 0, 0.493977,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0581848);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -2.57982, 1, 1, 0.517463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464238,-99) , 
1, -2.84608, 0, 0, 0.510833,-99) , 
NN(
0, 
0, 
-1, 51.5979, 1, -1, 0.447206,-99) , 
9, 3.0065, 1, 0, 0.502204,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0502119);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.558111,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486046,-99) , 
1, -2.28531, 1, 0, 0.497308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452026,-99) , 
2, 1.57393, 1, 0, 0.492664,-99) , 
0, 2727, 0, 0, 0.494732,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0843605);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2134.3, 0, 1, 0.529411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46365,-99) , 
12, 227.096, 0, 0, 0.515229,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617991,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495447,-99) , 
12, 271.896, 1, 0, 0.549476,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448918,-99) , 
0, 1407.98, 0, 0, 0.471742,-99) , 
11, 84.3392, 1, 0, 0.486281,-99) , 
1, 1.33182, 0, 0, 0.499651,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0765349);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596727,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513592,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472935,-99) , 
2, -0.28909, 0, 0, 0.495373,-99) , 
12, 184.474, 1, 0, 0.504679,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536502,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480366,-99) , 
12, 380.908, 1, 0, 0.506431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426019,-99) , 
12, 276.972, 0, 0, 0.472273,-99) , 
9, 2.89783, 1, 0, 0.496563,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0784241);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638476,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493392,-99) , 
4, 20.3522, 1, 0, 0.504054,-99) , 
12, 182.699, 1, 0, 0.51383,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522005,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538416,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451157,-99) , 
14, 0.0441402, 1, 0, 0.463543,-99) , 
13, 0.0107656, 0, 0, 0.474965,-99) , 
2, 0.184755, 1, 0, 0.496121,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0651087);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 182.699, 1, 1, 0.525768,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529123,-99) , 
NN(
0, 
0, 
-1, 19.8262, 0, -1, 0.471401,-99) , 
1, 2.66034, 0, 0, 0.482374,-99) , 
2, 0.184755, 1, 0, 0.50601,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0873559);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55738,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481799,-99) , 
12, 281.503, 1, 0, 0.519385,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514698,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414642,-99) , 
12, 268.164, 0, 0, 0.490309,-99) , 
4, 56.0072, 1, 0, 0.505832,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520232,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434485,-99) , 
7, 0.510677, 1, 0, 0.47027,-99) , 
3, -3.05515, 0, 0, 0.501744,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0677617);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591524,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608952,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495895,-99) , 
0, 2223.76, 0, 0, 0.502785,-99) , 
4, 49.7704, 0, 0, 0.511161,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476503,-99) , 
10, 3.10705, 0, 0, 0.492924,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425986,-99) , 
12, 252.444, 0, 0, 0.479526,-99) , 
4, 56.0072, 1, 0, 0.497596,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0786582);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487633,-99) , 
7, 0.535244, 1, 0, 0.568141,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547836,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486427,-99) , 
8, 0.932431, 0, 0, 0.509344,-99) , 
12, 216.986, 1, 0, 0.523063,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.58027,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493431,-99) , 
10, 3.10705, 0, 0, 0.505246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442634,-99) , 
12, 252.444, 0, 0, 0.492742,-99) , 
4, 56.0072, 1, 0, 0.510073,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0698214);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0425113, 1, 1, 0.528549,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450936,-99) , 
14, 0.0346954, 0, 0, 0.5231,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479172,-99) , 
2, 1.57393, 1, 0, 0.518643,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0479924);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560561,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511896,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465835,-99) , 
2, -1.49308, 0, 0, 0.505985,-99) , 
12, 180.816, 1, 0, 0.51038,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45794,-99) , 
8, 0.998461, 1, 0, 0.506951,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0521829);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448259,-99) , 
12, 165.658, 0, 0, 0.509121,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455316,-99) , 
9, 1.82305, 0, 0, 0.50357,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503989,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430822,-99) , 
8, 0.849055, 0, 0, 0.468253,-99) , 
12, 527.264, 1, 0, 0.499169,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0340836);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538594,-99) , 
NN(
0, 
0, 
-1, 0.445917, 0, -1, 0.491525,-99) , 
7, 0.411148, 1, 0, 0.495513,-99) , 
NN(
0, 
0, 
-1, -0.388645, 0, -1, 0.461391,-99) , 
3, -3.05515, 0, 0, 0.49159,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0356288);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556157,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505562,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44991,-99) , 
9, 3.00073, 1, 0, 0.499732,-99) , 
15, 0.097869, 1, 0, 0.502592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502464,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440498,-99) , 
1, -0.388645, 0, 0, 0.469875,-99) , 
3, -3.05515, 0, 0, 0.498834,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0861431);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.599671,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510514,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421826,-99) , 
5, 0.250452, 1, 0, 0.487539,-99) , 
5, 0.327932, 0, 0, 0.50854,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466875,-99) , 
9, 2.22032, 0, 0, 0.503419,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501515,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414953,-99) , 
1, 2.74978, 0, 0, 0.458577,-99) , 
15, 0.393271, 0, 0, 0.485108,-99) , 
1, -2.28531, 1, 0, 0.492568,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0633533);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573056,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459444,-99) , 
12, 281.328, 1, 0, 0.519901,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503195,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468112,-99) , 
5, 0.211707, 0, 0, 0.487105,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.40203,-99) , 
15, 0.649946, 1, 0, 0.481184,-99) , 
15, 0.700865, 0, 0, 0.485874,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0721238);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588898,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474105,-99) , 
8, 0.681401, 1, 0, 0.518954,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480989,-99) , 
15, 0.590015, 0, 0, 0.486707,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.425898,-99) , 
15, 0.633491, 1, 0, 0.481043,-99) , 
15, 0.700865, 0, 0, 0.485626,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0480746);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647019,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475737,-99) , 
4, 31.1178, 1, 0, 0.54322,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567812,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493334,-99) , 
8, 0.998588, 0, 0, 0.497345,-99) , 
12, 207.292, 1, 0, 0.503425,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456242,-99) , 
5, 0.422879, 1, 0, 0.500176,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0594404);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.97221, 0, 1, 0.51893,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528446,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402592,-99) , 
3, 3.07556, 0, 0, 0.474564,-99) , 
3, 3.03214, 1, 0, 0.513008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466527,-99) , 
8, 0.998461, 1, 0, 0.50999,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0442086);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579475,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510555,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477903,-99) , 
3, -2.68279, 0, 0, 0.498999,-99) , 
4, 9.25646, 1, 0, 0.50159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.45871,-99) , 
5, 0.422879, 1, 0, 0.49865,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0616931);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.573774,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517822,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480591,-99) , 
8, 0.724236, 1, 0, 0.495728,-99) , 
3, 2.97221, 0, 0, 0.500141,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522546,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424842,-99) , 
15, 0.425679, 1, 0, 0.469756,-99) , 
3, 3.03214, 1, 0, 0.496163,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0896689);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596817,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48379,-99) , 
14, 0.108074, 0, 0, 0.501502,-99) , 
8, 0.72429, 1, 0, 0.508353,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542354,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456491,-99) , 
14, 0.0862212, 1, 0, 0.499246,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.39174,-99) , 
4, 19.9179, 0, 0, 0.48,-99) , 
8, 0.645649, 0, 0, 0.497929,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0832517);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.591695,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477851,-99) , 
13, 0.00142792, 0, 0, 0.505731,-99) , 
12, 187.792, 1, 0, 0.512046,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530106,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455807,-99) , 
12, 354.89, 1, 0, 0.499337,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413307,-99) , 
4, 19.9179, 0, 0, 0.484009,-99) , 
8, 0.645649, 0, 0, 0.501754,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0739778);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.623366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496288,-99) , 
7, 0.516439, 0, 0, 0.54956,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449098,-99) , 
8, 0.851236, 1, 0, 0.490501,-99) , 
10, 3.02529, 0, 0, 0.519541,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486273,-99) , 
6, 0.459463, 1, 0, 0.49671,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.41831,-99) , 
13, 0.00117363, 0, 0, 0.48964,-99) , 
13, 0.000819952, 1, 0, 0.498726,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.075185);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.264275, 0, 1, 0.568103,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540094,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452966,-99) , 
1, 1.15331, 0, 0, 0.492926,-99) , 
14, 0.0896803, 1, 0, 0.527875,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586403,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511962,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472445,-99) , 
14, 0.0819136, 0, 0, 0.493729,-99) , 
4, 13.1081, 1, 0, 0.499133,-99) , 
5, 0.146812, 1, 0, 0.506494,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.062755);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586602,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544685,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491188,-99) , 
12, 323.008, 0, 0, 0.511977,-99) , 
14, 0.064312, 0, 0, 0.524984,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452104,-99) , 
0, 1069.83, 0, 0, 0.496937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422408,-99) , 
14, 0.0773958, 0, 0, 0.490496,-99) , 
14, 0.0717986, 1, 0, 0.502646,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0991265);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.588847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492878,-99) , 
12, 288.69, 1, 0, 0.548112,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53152,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.437496,-99) , 
10, 2.71713, 1, 0, 0.49439,-99) , 
4, 57.6732, 1, 0, 0.52519,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.581191,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445487,-99) , 
6, 0.518434, 0, 0, 0.519225,-99) , 
NN(
0, 
0, 
-1, 0.732313, 0, -1, 0.472907,-99) , 
1, -2.54906, 1, 0, 0.483394,-99) , 
14, 0.0717986, 1, 0, 0.498112,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0679863);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 323.008, 0, 1, 0.523737,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47034,-99) , 
12, 508.343, 1, 0, 0.516635,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482251,-99) , 
9, 2.80598, 0, 0, 0.505683,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429495,-99) , 
14, 0.131057, 0, 0, 0.488276,-99) , 
14, 0.119552, 1, 0, 0.508707,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0849359);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596811,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499542,-99) , 
1, 0.892266, 0, 0, 0.54257,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514532,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453928,-99) , 
3, -1.07923, 0, 0, 0.497561,-99) , 
3, -2.78946, 1, 0, 0.511045,-99) , 
NN(
NN(
0, 
0, 
-1, 217.985, 1, 1, 0.531477,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.402725,-99) , 
15, 0.300486, 1, 0, 0.456456,-99) , 
15, 0.488028, 0, 0, 0.485945,-99) , 
8, 0.645649, 0, 0, 0.501837,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0974924);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600888,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464378,-99) , 
8, 0.643858, 0, 0, 0.505422,-99) , 
9, 2.06122, 1, 0, 0.514708,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523166,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445517,-99) , 
7, 0.547459, 1, 0, 0.495545,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512079,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421709,-99) , 
7, 0.495222, 1, 0, 0.450079,-99) , 
2, 0.700518, 1, 0, 0.480962,-99) , 
3, -2.38474, 1, 0, 0.495152,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0682383);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574702,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.618379,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490456,-99) , 
0, 2239.66, 0, 0, 0.498172,-99) , 
3, -2.64149, 0, 0, 0.506892,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580179,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482608,-99) , 
8, 0.979142, 0, 0, 0.505781,-99) , 
NN(
0, 
0, 
-1, 0.109723, 0, -1, 0.467446,-99) , 
1, -2.39579, 1, 0, 0.479011,-99) , 
3, -2.38474, 1, 0, 0.490736,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0544925);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.603637,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549037,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497623,-99) , 
5, 0.146994, 1, 0, 0.507449,-99) , 
7, 0.488042, 1, 0, 0.512603,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530162,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512449,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43945,-99) , 
11, 100.084, 1, 0, 0.46734,-99) , 
14, 0.132579, 0, 0, 0.481562,-99) , 
7, 0.478205, 0, 0, 0.503981,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0758908);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590529,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488562,-99) , 
3, 2.74945, 1, 0, 0.515873,-99) , 
7, 0.488042, 1, 0, 0.519854,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535948,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461194,-99) , 
13, 0.00362904, 1, 0, 0.495602,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443993,-99) , 
15, 0.264019, 0, 0, 0.480924,-99) , 
7, 0.478205, 0, 0, 0.509051,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0828928);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.572102,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.554636,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471913,-99) , 
3, -1.81591, 1, 0, 0.506346,-99) , 
5, 0.202453, 1, 0, 0.527151,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486923,-99) , 
9, 2.6432, 1, 0, 0.552081,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.541789,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480675,-99) , 
8, 0.995983, 0, 0, 0.488781,-99) , 
12, 210.681, 1, 0, 0.498445,-99) , 
7, 0.555637, 0, 0, 0.506063,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0609925);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575922,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520629,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474237,-99) , 
2, -1.43456, 0, 0, 0.514068,-99) , 
12, 179.116, 1, 0, 0.518702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475118,-99) , 
8, 0.997496, 1, 0, 0.514686,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0667867);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 95.138, 1, 1, 0.548194,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510751,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460749,-99) , 
3, -3.05621, 0, 0, 0.503397,-99) , 
0, 1650.9, 0, 0, 0.512572,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457542,-99) , 
7, 0.501925, 0, 0, 0.505675,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440883,-99) , 
0, 1671.31, 1, 0, 0.487625,-99) , 
4, 77.0975, 1, 0, 0.505882,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0276079);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527217,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.564149,-99) , 
NN(
0, 
0, 
-1, 167.526, 1, -1, 0.491759,-99) , 
0, 2727, 0, 0, 0.493787,-99) , 
11, 184.864, 0, 0, 0.497039,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0435741);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.579353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470038,-99) , 
12, 293.407, 1, 0, 0.530141,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567916,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496505,-99) , 
3, 2.9294, 0, 0, 0.503145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453862,-99) , 
3, 3.0321, 1, 0, 0.498514,-99) , 
4, 17.6455, 1, 0, 0.50225,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0641213);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 2.03672, 1, 1, 0.542308,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523115,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483381,-99) , 
9, 2.47942, 0, 0, 0.506781,-99) , 
0, 1650.73, 0, 0, 0.514772,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452008,-99) , 
13, 0.0024308, 0, 0, 0.486771,-99) , 
2, 1.26366, 1, 0, 0.510117,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0400891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472213,-99) , 
8, 0.923317, 1, 0, 0.533145,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550978,-99) , 
NN(
0, 
0, 
-1, 576.149, 1, -1, 0.49534,-99) , 
14, 0.180441, 0, 0, 0.499464,-99) , 
9, 2.03531, 1, 0, 0.505202,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0451939);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 188.854, 0, 1, 0.515988,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448146,-99) , 
11, 120.214, 1, 0, 0.484157,-99) , 
9, 3.02058, 1, 0, 0.512148,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0429648);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577292,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460268,-99) , 
14, 0.0768239, 0, 0, 0.528139,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497974,-99) , 
9, 2.03495, 1, 0, 0.504241,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448376,-99) , 
15, 0.631181, 1, 0, 0.498844,-99) , 
15, 0.702012, 0, 0, 0.502308,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0483302);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548324,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515008,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472856,-99) , 
6, 0.430332, 0, 0, 0.508319,-99) , 
4, 102.881, 0, 0, 0.511877,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473682,-99) , 
4, 142.887, 1, 0, 0.509555,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0659829);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600213,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508615,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441371,-99) , 
11, 121.062, 0, 0, 0.500247,-99) , 
11, 114.553, 1, 0, 0.510053,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536213,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481127,-99) , 
7, 0.548752, 1, 0, 0.516164,-99) , 
NN(
0, 
0, 
-1, 89.3562, 1, -1, 0.462968,-99) , 
9, 2.61465, 1, 0, 0.491707,-99) , 
11, 107.134, 0, 0, 0.502227,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0654847);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.593874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474493,-99) , 
4, 31.1178, 1, 0, 0.52292,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532741,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486344,-99) , 
12, 324.5, 0, 0, 0.509541,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460057,-99) , 
11, 116.302, 1, 0, 0.481829,-99) , 
9, 2.72806, 0, 0, 0.492849,-99) , 
12, 207.292, 1, 0, 0.497089,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0580141);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.580845,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484037,-99) , 
9, 2.60545, 1, 0, 0.526099,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522469,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463068,-99) , 
10, 1.1131, 0, 0, 0.509557,-99) , 
NN(
0, 
0, 
-1, 2.36721, 1, -1, 0.482248,-99) , 
9, 2.72806, 0, 0, 0.493108,-99) , 
12, 207.292, 1, 0, 0.497751,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0493158);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585562,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495747,-99) , 
13, 0.000854591, 1, 0, 0.528071,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461172,-99) , 
13, 0.000437039, 0, 0, 0.517174,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500004,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449594,-99) , 
2, 1.10497, 1, 0, 0.489154,-99) , 
7, 0.544083, 0, 0, 0.498581,-99) , 
12, 207.292, 1, 0, 0.502726,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0668692);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.0580171, 1, 1, 0.531577,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532353,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.473544,-99) , 
8, 0.622834, 0, 0, 0.509993,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546785,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476176,-99) , 
3, -3.07202, 1, 0, 0.482124,-99) , 
7, 0.544083, 0, 0, 0.491493,-99) , 
12, 207.292, 1, 0, 0.497124,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0565601);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587321,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455966,-99) , 
7, 0.505088, 1, 0, 0.489279,-99) , 
6, 0.53765, 1, 0, 0.520798,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54176,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494176,-99) , 
4, 19.3415, 1, 0, 0.500428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442037,-99) , 
8, 0.477706, 0, 0, 0.496067,-99) , 
8, 0.367908, 1, 0, 0.501551,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0427026);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 2.97221, 0, 1, 0.513601,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525654,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433383,-99) , 
6, 0.532451, 1, 0, 0.480919,-99) , 
3, 3.03214, 1, 0, 0.509315,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0482525);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.574189,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.565706,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49565,-99) , 
11, 188.784, 0, 0, 0.500738,-99) , 
9, 2.84042, 0, 0, 0.505578,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479685,-99) , 
8, 0.978556, 1, 0, 0.512286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448778,-99) , 
8, 0.752932, 0, 0, 0.483682,-99) , 
9, 2.89677, 1, 0, 0.499998,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT_VBF0LowVPtHighMJJ::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT_VBF0LowVPtHighMJJ::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
